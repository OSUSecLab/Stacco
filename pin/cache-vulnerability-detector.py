import sys

def split_segment_lines(combined_index_line, segment_lines):
	parts = []
	segment_lines1 = []
	segment_lines2 = []
	if "a" in combined_index_line:
		# print "a"
		parts = combined_index_line.split("a")
		segment_lines1 = []
		segment_lines2 = segment_lines
	elif "d" in combined_index_line:
		# print "d"
		parts = combined_index_line.split("d")
		segment_lines1 = segment_lines
		segment_lines2 = []
	elif "c" in combined_index_line:
		# print "c"
		parts = combined_index_line.split("c")
		flag = 1 # Means lines belonging to left
		for line in segment_lines:
			if line[0] == "-":
				# print "Found ---"
				flag = 2 # Below are lines belonging to right
			elif flag == 1:
				segment_lines1.append(line)
			elif flag == 2: # Means belonging to right
				segment_lines2.append(line)
	else:
		print "Invalid combined_index_line"
		return None

	index_line1 = parts[0]
	index_line2 = parts[1]

	# print "segment_lines1: "
	# for line in segment_lines1:
	# 	print line

	# print "segment_lines2: "
	# for line in segment_lines2:
	# 	print line

	return [segment_lines1, segment_lines2, index_line1, index_line2]

def segment_to_clset(segment_lines, index_line, orig_data, way):
	clset = []
	# Include prev and next
	segment_lines.insert(0, "> " + get_prev_bb_line(index_line, orig_data))
	segment_lines.append("> " + get_next_bb_line(index_line, orig_data))

	for segment_line in segment_lines:
		# print "Splitting: " + segment_line
		parts = segment_line.split(" ")
		if parts[1] != "bb":
			return None
		address = int(parts[2], 16)
		cacheline = (address // 64) % way
		# image = parts[5]
		# page = (int(address, 16) & 0xFFFFF000) + (int(image) * 0x100000000)
		if len(clset) == 0 or cacheline not in clset:
			clset.append(cacheline)
	return clset

def is_clset_different(clset1, clset2):
	if len(clset1) != len(clset2):
		return True
	for cacheline in clset1:
		if cacheline not in clset2:
			return True
	return False

# def is_clset_different_middle(clset1, clset2):
# 	if len(clset1) < 3 or len(clset2) < 3:
# 		print "Length too short for middle part comparison"
# 		return False
# 	return is_clset_different(clset1[1:len(clset1)-1], clset2[1:len(clset2)-1])

# These two functions may include some little bugs about 1-line/0-line situations
def get_prev_bb_line(index_line, orig_data):
	parts = index_line.split(",");
	if len(parts) == 1:
		start = parts[0]
	elif len(parts) == 2:
		start = parts[0]
	else:
		print "Index line too many parts: " + index_line
		start = parts[0]
	return orig_data[int(start)-2]

def get_next_bb_line(index_line, orig_data):
	parts = index_line.split(",");
	if len(parts) == 1:
		end = parts[0]
	elif len(parts) == 2:
		end = parts[1]
	else:
		print "Index line too many parts: " + index_line
		end = parts[1]
	return orig_data[int(end)]

def is_segment_vulnerable(combined_index_line, segment_lines, orig_data1, orig_data2, way):
	[segment_lines1, segment_lines2, index_line1, index_line2] = split_segment_lines(combined_index_line, segment_lines)

	clset1 = segment_to_clset(segment_lines1, index_line1, orig_data1, way)
	if clset1 is None:
		return False
	# head1 = clset1[0]
	# tail1 = clset1[len(clset1)-1]
	# prev1 = get_prev_bb_page(index_line1, orig_data1)
	# next1 = get_next_bb_page(index_line1, orig_data1)

	clset2 = segment_to_clset(segment_lines2, index_line2, orig_data2, way)
	if clset2 is None:
		return False
	# head2 = clset2[0]
	# tail2 = clset2[len(clset2)-1]
	# prev2 = get_prev_bb_page(index_line2, orig_data2)
	# next2 = get_next_bb_page(index_line2, orig_data2)

	# Include prev and next in clset
	if not is_clset_different(clset1, clset2):
		return False
	else:
		print "Different cacheline sets:"
		for pg in clset1:
			print pg
		print "and"
		for pg in clset2:
			print pg
		return True


#_*_*_*_*_*_*_*_*_*_*_*_*_*_*_*_*_*_*_*_*_*_*_*_*_*_*_*_*_*_*

diff_file = sys.argv[1]
orig_trace1 = sys.argv[2]
orig_trace2 = sys.argv[3]
lines = open(diff_file, 'r').readlines()
orig_data1 = open(orig_trace1, 'r').readlines()
orig_data2 = open(orig_trace2, 'r').readlines()

argc = len(sys.argv)
if argc < 5:
	way = 8; # default way = 8
else:
	way = int(sys.argv[4])

segment_start = 0
vulnerable = False
for i in range(1, len(lines)):
	line = lines[i]
	first_letter = line[0]

	# Start of a segment
	if first_letter.isdigit():
		combined_index_line = lines[segment_start]
		# print "Testing index: " + combined_index_line
		segment_lines = lines[segment_start+1:i]
		segment_start = i
		# for line in segment_lines:
		# 	print "Testing: " + line
		if is_segment_vulnerable(combined_index_line, segment_lines, orig_data1, orig_data2, way):
			print "Vulnerability found in " + combined_index_line
			vulnerable = True
			# break

if not vulnerable:
	print "No cacheline vulnerabilities found!"
